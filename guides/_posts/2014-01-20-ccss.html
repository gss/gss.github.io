---
uid: CCSS
title: Constraint CSS
subtitle: lay it out like it's 1999
color: b
layout: post
---

Soon after the W3C introduced Cascading Style Sheets, [Greg Badros](http://www.badros.com/greg/), the author of the Cassowary Constraint
Solver & [recently retired Facebook VP](http://allthingsd.com/20130920/facebook-engineering-and-products-vp-greg-badros-to-leave-company/),
proposed [Constraint CSS (CCSS)](http://www.cs.washington.edu/research/constraints/web/ccss-uwtr.pdf) as a general solution for CSS layout.
Back in '99 Badros demonstrated *responsive* layouts with CCSS that today's designers still can't reproduce without grinding out piles of JavaScript.
For more than a decade, no one seemed to take notice outside academia... Until Apple implemented Cassowary & Greg's pioneering concepts in its new
AutoLayout engine with the launch of OS X Lion. Despite the evolutionary leap for app developers, web designer's have had to settle
with [float-based](http://www.sitepoint.com/give-floats-the-flick-in-css-layouts/) & table-based layouts that have remained unimproved to this day.

> "We should contemplate how very, very far behind the web platform is in making it delightful to build the sorts of things that are work-a-day in native environments." <a href="http://infrequently.org/2012/02/misdirection/">Alex Russell</a>

The foundation of GSS is a modernized implementation of CCSS.  From CCSS primitives other, more exotic layout API's can and are accomplished.


<a name="basicconstraint"></a>
## Constraints, the basics

Constraints express [relationships between variables](#constraintsaretwoway) that [may or may not hold](#mayormaynothold).
Any numeric property of an element can be constrained, not just position & size.

In the following example, all paragraph tags are constrained to have line-height greater than 16px and
less than 1/12th the size of the window:

{% highlight css %}

p[line-height] >= 16;
p[line-height] <= ::window[height] / 12;

{% endhighlight %}

### Constraint declaration

The syntax for declaring a constraint is as follows:

`p[line-height] >= 16;`

+ `p` is the selector. This constraint will apply to every `p` tag in the page.
+ `[]` is the property accessor syntax.
+ `line-height` is the property for which a value will be calculated by GSS.
+ `>=` defines an inequality constraint. You can declare inequality and equality constraint.
+ `16` is the numerical value for the constraint in pixels (the default [unit of measurement](/guides/references#unitofmeasurement) in GSS).

<a href="http://codepen.io/cbchouinard/pen/OPmdVL" target="_blank">Live example</a>

<a name="constraintsaretwoway"></a>
### Constraints are two-way
Do not confuse an equality constraint with your everyday variable assignment. For example, in a vanilla programming paradigm:

{% highlight javascript %}

// vanilla programming

x = y;
y = 10
x = 100;

// x => 100, y => 10

{% endhighlight %}

x will be 100, and y will be 10.  With constraint programming, equality constraints are two-way, so:

{% highlight javascript %}

// constraint programming

x == y;
x == 100;
y >= 10;

// x => 100, y => 100

{% endhighlight %}

x and y have a constraint to be equal, so x and y will be 100.

Constraints are incrementally added to a `solver`, then the solver computes a feasible & optimal solution to all the constraints.
Constraint programming focuses on intentions, not implementation. This makes constraint solver a perfect fit for empowering declarative languages like CSS.

Regular imperative programming approach focuses on the implementation instead, making programmer solve the problems.

<a name="mayormaynothold"></a>
### Constraints May or may not hold
GSS will find the best solution that satisfies the defined constraints. It uses uses "soft" constraints,
which means that it is preferred but not required that certain constraints be satisfied.

For example:

{% highlight css %}

#gss[width] == 200;
#cassowary[width] == 200;
#gss[width] + #cassowary[width] == 350;

{% endhighlight %}

`#GSS` and `#cassowary` elements are constrained to have width of 200px initially, and then the sum of those two is set to equal 350px. In this case, one of these
two constraints will not hold. <a href="http://codepen.io/cbchouinard/pen/XJROdV" target="_blank">Live example.</a>

<a name="strengths"></a>
## Strengths

It is possible to influence the solution by prioritizing the constraints with strengths.

Stronger constraints completely overcome weaker ones - this is the phenomena of the [Constraint Hierarchy](http://www.cs.washington.edu/research/constraints/theory/hierarchies-92.html).  Strengths are declared in the same fashion of CSS's `!important`:

{% highlight css %}

/* Stronger constraints are more important */

#light[years] == 100 !weak;
#light[years] == 200 !medium;
#light[years] == 300 !strong;

/* #light[years] will be 300 */

{% endhighlight %}

There are 4 levels of built-in strength:

- `!weak`
- `!medium` (default)
- `!strong`
- `!require`


In a [previous example](#mayormaynothold),
strengths assigned to constraints allow individual `width` constraints to overcome the sum constraint: <a href="http://codepen.io/cbchouinard/pen/bNRbQg" target="_blank">Live example.</a>

#### !require strength
`!require` is a special strength that guarantees the constraint will hold, otherwise everything breaks.

**Pro Tip** Use `!require` carefully & sparingly. `!require`'s quickly lead to systems where
all required constraints cannot be satisfied in which case the GSS engine will throw an error.

For example, the following GSS constraints will be unsolvable and thus throw an exception:

{% highlight css %}

#gss[width] == 200 !require;
#cassowary[width] == 200 !require;
#gss[width] + #cassowary[width] == 350 !require;

{% endhighlight %}

We're asking GSS to find a solution where the widths of the #gss and #cassowary element must be 200px
and their sum must be 350px which is impossible.

### Constraints order
Generally speaking, later constraint declarations of the same strength are more powerful than earlier ones. There are exceptions to this behavior,
as we'll see in the following sections.

In a [previous example](#mayormaynothold)  with conflicting strengths, altered order of constraints yields a
different result. <a href="http://codepen.io/cbchouinard/pen/rawBRr" target="_blank">Live example.</a>

<a name="lineararithmetic"></a>
## Linear Arithmetic

Cassowary, which is the constraints solving algorithm used by GSS, can only compute "Linear Arithmetic" constraints. Simple math operations like `+`, `-`, `*` and `/` are all supported, but the expressions must be linear (of the form `y = mx + b`).  Basically, you can do everything except division and multiplication of two constrained variables.
<a href="http://codepen.io/cbchouinard/pen/MYvOWO" target="_blank">Live example.</a>

{% highlight css %}

/* this is not linear & will throw an error */

#box1[width] / #box2[height] == varX;

{% endhighlight %}

<a name="selectors"></a>
## Selectors

Selector is a query over a tree of HTML elements. They determine which elements are affected by the constraint.

{% highlight css %}
// elements with tag name div within element with #something id
(#something div)[width] == 100;
{% endhighlight %}

There are many kinds of selectors, so there is a dedicated guide for them. We invite you to read all of it since there are some useful
information at the bottom: [GSS Selectors Guide](/guides/selectors) \*

\* Note that this guide is refering to [rulesets](rulesets) which are covered next.

<a name="rulesets"></a>
## Rulesets

Rulesets allow multiple constraints to be defined over a single selector

{% highlight css %}
  .selector {
    width: == 100;
  }
{% endhighlight %}

Within a ruleset, constraints are defined on properties using the same syntax as CSS using colon `:` followed by a equality sign.

Rulesets can be nested:

{% highlight css %}
section > article {
   .someclass {
       width: == 100;
    }
}

// is equivalent of
(section > article .someclass)[width] == 100;

{% endhighlight %}

CSS properties can be defined in the rulesets just like in CSS:

{% highlight css %}
div {
   background-color: green;
   width: <= 200;
}
{% endhighlight %}

### Selectors within rulesets

Selectors within ruleset body are scoped to the elements matching the ruleset selector. For example:

{% highlight css %}
div {
  width: <= .widget[width];
}
{% endhighlight %}

`<div>` elements will constrain their width to width of their descendants having the class name `widget`, if they have any.
<a href="http://codepen.io/cbchouinard/pen/yyXPyK" target="_blank">Live example.</a>


`$` combinator makes selectors in ruleset body apply to the root of a document ignoring the nesting:

{% highlight css %}
div {
  width: <= ($ #elm)[width];
}
{% endhighlight %}

`^` combinator makes selectors in ruleset body apply to the elements selected by the parent ruleset:

In this following example '^' will move up to the current `.container` element and will search its descendants
for an element with `elm` id. <a href="http://codepen.io/cbchouinard/pen/yyXPej" target="_blank">Live example.</a>

{% highlight css %}

.container {
  div {
    width: <= (^ #elm)[width];
  }
}

{% endhighlight %}


## Properties
Properties are variables belonging to an element. All previous examples constrained CSS properties like `width` or `line-height`.
It is possible to constrain custom properties that are not recognized by CSS, but can be used in GSS constraints over known
CSS properties.

When using a property known by CSS, the GSS computed value for that property will be assigned as an inline style in pixels
to the element.

Like `$` and `^` combinators, `&` combinator refers to current element matching the ruleset selector. It is implied by the use of `width: ==` property notation.

{% highlight css %}
.container {
  width: == #elm[width];
}

/* It is the same as: */

.container {
  &[width] == #elm[width];
}

{% endhighlight %}

It is possible to constrain custom properties that are not recognized by CSS, but can used in constraints over known CSS properties.


{% highlight css %}

.post {
  custom-property: == &[line-height] * 3;
}

/* equals to */

.post[custom-property] == .post[line-height] * 3;

{% endhighlight %}

This will automatically create a `custom-property` for each element having a `.post` class. The element's `custom-property` will be constrained to be thrice its own `line-height`.

Because of the 2-way binding, changing either `custom-property` or `line-height` will affect the other property of the element.


Properties on special combinators like `&`, `$` or `^` may omit square brackets:

{% highlight css %}

body {
  .container {
    // equate width of a <body> element with width of elements having container class
    &width == ^width;
  }
}

{% endhighlight %}


<a name="scope"></a>
## Scope

Properties are attached to a specific element:
  * In rulesets, it's an element that matches the selector
  * In topmost level of a stylesheet, it's a `<link>` or `<style>` that defines the stylesheet.
  * In stylesheet element with `scoped` attribute, topmost variables are attached to the parent element of a stylesheet.

Variables prefixed with `$` combinator are considered global, and can be shared by different stylesheets.


### Properties in stylesheet

Properties defined at the top level of a stylesheet will be attached to the stylesheet element. Thus each stylesheet provides its own scope. Top level properties are not directly accessible from other stylesheets.

{% highlight css %}
<style type="text/gss">
  varX: == 100;
  varX: == #elm1[width];
</style>

<style type="text/gss">
  varX: == 200;
  varX: == #elm1[width];
</style>
{% endhighlight %}

In this example, `#elm1` will have a width of 100px and `#elm2` will have a width of 200px.
The two `varX` are in different scopes and are therefore indenpendent from each other.
<a href="http://codepen.io/cbchouinard/pen/EaXmRp" target="_blank">Live example.</a>

Global variables prefixed with `$`, are accessible accross stylesheets. In the previous example, using `$varX` instead of `varX` makes constraints operate on the same variable, making the widths of two elements equal. <a href="http://codepen.io/cbchouinard/pen/yyoxxm" target="_blank">Live example.</a>

Adding a `scoped` attribute to the stylesheet attaches top most properties to the parent element of a stylesheet. If two `scoped` stylesheets share the parent element, they will automatically share the topmost variables.

The same scoping logic applies to external GSS files.


### Properties in rulesets

Variables defined inside a ruleset define a property on each element that matches the ruleset selector.

{% highlight css %}
.someClass {
  varX: == 100;
  width: == &[varX];
}

.someOtherClass {
  varX: == 100;
  width: == &[varX];

}
{% endhighlight %}

In this case, both rulesets define `varX` property for matching elements. If there's an element that matches both rulesets, it will have both constraints applied over a single property. This may lead to a conflict local to that element.

The latter constraint will win in case of conflict if element had both classes from the start. Otherwise the class that was added the latest will "win". Strengths can be used to define the importance of each constraint independent from order of changes. <a href="http://codepen.io/cbchouinard/pen/XJgRPq" target="_blank">Live example.</a>


<a name="variables"></a>
## Variables

Variables are properties that dont have explicit scope and can be accessed from inner scopes.  This concept is known as lexical scoping. The scoping is determined by the source code, so it's *static* and does not change in runtime.

We say that topmost scope that defines variable *captures* the variable, making variables in the inner scopes *hoisted*.


{% highlight css %}

<style text='text/gss'>
varX == 100;

.className {
  width: == varX;   // same as &width == ^varX
  varY == &[height];

  #div {
    width: == varX; // same as &width == ^^varX
  }
}
</script>

{% endhighlight %}

If a `varX` was defined as a property on the top level (e.g. `varX: == 100`), the variable would be captured at the `.className` level instead.


The order of appearance or square brackets around variables have no effect over hoisting:

{% highlight css %}

div {
  .rule {
    [varX] == 200; /* hoisted to parent, same as ^varX*/
  }

  [varX] == 100; /* equivalent to varX == 100; */

{% endhighlight %}


Variables are properties in disguise. If a variable has a name of a CSS property, it will apply the style for its resolved scope element. This fact can be used to define declarative constraints based on the DOM structure.

{% highlight css %}
<style text='text/gss'>
varX = 100;

.wrapper {
  width == varX;

  section {
    width == &height;
  }
}
</script>

{% endhighlight %}

`width` variable in the `.wrapper` ruleset captures `width` variable within `section` ruleset. Therefore an element having `wrapper` class name will have its width equal to height of its descendant sections, if there are any.

Rulesets can be nested arbitarily deep, and the hoisting reference is computed for each variable individually. A variable that was not defined in any of its parent scopes, is considered local and is identical to property.

{% highlight css %}
div {
  varX == 40; // captured varX

  .someClass {
    width: == varX;

    .someNestedClass {
        varY == 45;
        width: == varY;  // captured varY
        top: == varX;
    }

    .someOtherNestedClass {
        varY == 60;
        height: == varY;  // captured varY
        width: == varX;
      }
  }
}
{% endhighlight %}

In this case, all nested rulesets will share `varX` variable through parent ruleset. Nested rulesets also define `varY` variables that are not hoisted and act like local properties. <a href="http://codepen.io/cbchouinard/pen/zxzwXJ" target="_blank">Live example.</a>

Only variables capture other variables within inner rulesets. Anything that has explicit scope is considered a property. Properties do not capture and are not hoisted. Examples would be `$global` variables and `&local` variables. `property: ==` notation is the cleanest way to define property in a ruleset:

{% highlight css %}
div {
  varX: == 40; /* property constraint */
  varY == 45; /* variable constraint */

  .someClass {
    /* varX is not hoisted here since on the parent scope varX is a property. */
    /* A new variable varX is there created and scoped to .someClass */
    width: == varX;

    .someNestedClass {
      /* varY is hoisted from the div scope since it's scoped at that level */
      width: == varY;
      /* varX here is the .someClass varX scoped variable */
      top: == varX;
    }
  }
}
{% endhighlight %}

It is possible to opt out of hoisting in the same way by prepending `&` to a variable name, making it a property.

{% highlight css %}
div {
  varX == 50;

  .className {
    varX: == 60;
    width: == &varX; /*  60 since we are using the property varX */
  }
}
{% endhighlight %}

### Suggested variables

Javascript code can provide numerical values that can be used in constraints. The easiest way to do it, is to pass an object with values to GSS constructor:

{% highlight html %}

<script src="/bower_components/gss/dist/gss.js"></script>
<script type="text/javascript">
  GSS.document = new GSS(document, {"some-width": 400, "some-height": 150});
</script>

<style type="text/gss">

  section[width] == $some-width;
  section[height] == $some-height;

</style>

{% endhighlight %}

Suggested variables are global so they should be accessed with `$` combinator. <a href="http://codepen.io/cbchouinard/pen/pvWMJV" target="_blank">Live example.</a>

External variables are bound in one direction, so their values will not be affected by the solver. It is almost as if there were actual numbers in place of those variables. The difference is that these values can be updated dynamically without much effort on the solver side:

{% highlight html %}
  <script>
    document.onmousemove = (e) {
      GSS.document.solve({ // make mouse movement affect variables
        "some-width": e.clientX,
        "some-height": e.clientY
      })
    }
  </script>
{% endhighlight %}


<a name="position"></a>
## Position and dimension

Consult our [layout guide](/guides/layout) to learn more about positioning and dimensioning elements. Having a good
understanding of layout constraints will help you appreciate the next section about virtuals.

<a name="virtuals"></a>
## Virtuals
Virtuals are rectangles you define in GSS that don't have a representation in the DOM. You can contrain DOM element
and other virtuals against the dimension and position of virtuals. Virtual are a practical way to constrain a group of element
without the need for a DOM container element.

{% highlight css %}

  "area" {
    size: == ::window[size] / 2;
    center: == ::window[center];
  }

  #elmA[top-left] == "area"[top-left];
  #elmB[bottom-right] == "area"[top-right];

{% endhighlight %}

As you can see from the previous example, we are constraining `#elmA` and `#elmB` against the virtual element.
<a href="http://codepen.io/cbchouinard/pen/WbOWgB" target="_blank">Live example.</a>

In regards of constraining dimensions and positions, virtuals are no different from DOM element in the sens that you can
declare constraints on them as shown previously. The main difference is that since they don't exist in the DOM, they are
not stylable with CSS. Doing the following will have no effect:

{% highlight css %}

"area" {
  /* Styling virtuals have no effect since they don't exist in the DOM */
  background-color: blue;
}

{% endhighlight %}

### Virtual hoisting
Virtuals follow the same scoping rules as variables. You can do the following:

{% highlight css %}

.className {
  "area"[size] == 200;

  #someElm > div {
    width: == "area"[width]; /* "area" will be hoisted from the .className scope */
  }
}

{% endhighlight %}


### Virtual splat
Virtual splats allow you to create a grid of virtuals. For example, if you want to split the viewport in four equally dimensioned
virtuals you can do the following:

{% highlight css %}


"area1...4" {
  width: == ::window[width] / 2;
  height: == ::window[height] / 2;
}

"area1...2" {
  top: == 0;
  right: == &:next[left];
}

"area3...4" {
  right: == &:next[left];
}

"area1", "area3" {
  top: == &:previous[bottom];
}
"area2", "area4" {
  top: == &:previous[bottom];
}

{% endhighlight %}

Using those virtual boxes, you can now constrain DOM elements against those four boxes. <a href="http://codepen.io/cbchouinard/pen/VYzOPx" target="_blank">Live example.</a>


## Read next
GSS provides conditionnal statements to allow you to do responsive design. Read our [@if @else guide](/guides/ifelse) to learn more.

With only CCSS constraints at your disposal, constraining common layout scenarios quickly becomes tedious. Read our
[VFL guide](/guides/ifelse) to learn how to more efficiently constrain your layout.
